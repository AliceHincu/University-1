        -:    0:Source:/Users/taveeh/Qt/5.14.2/clang_64/lib/QtCore.framework/Headers/qbytearray.h
        -:    0:Graph:/Users/taveeh/Desktop/University/Year 1/Semester 2/Object Oriented Programming/Assignment_9/cmake-build-debug/CMakeFiles/Assignment_9.dir/GUI.cpp.gcno
        -:    0:Data:/Users/taveeh/Desktop/University/Year 1/Semester 2/Object Oriented Programming/Assignment_9/cmake-build-debug/CMakeFiles/Assignment_9.dir/GUI.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/****************************************************************************
        -:    2:**
        -:    3:** Copyright (C) 2016 The Qt Company Ltd.
        -:    4:** Copyright (C) 2016 Intel Corporation.
        -:    5:** Contact: https://www.qt.io/licensing/
        -:    6:**
        -:    7:** This file is part of the QtCore module of the Qt Toolkit.
        -:    8:**
        -:    9:** $QT_BEGIN_LICENSE:LGPL$
        -:   10:** Commercial License Usage
        -:   11:** Licensees holding valid commercial Qt licenses may use this file in
        -:   12:** accordance with the commercial license agreement provided with the
        -:   13:** Software or, alternatively, in accordance with the terms contained in
        -:   14:** a written agreement between you and The Qt Company. For licensing terms
        -:   15:** and conditions see https://www.qt.io/terms-conditions. For further
        -:   16:** information use the contact form at https://www.qt.io/contact-us.
        -:   17:**
        -:   18:** GNU Lesser General Public License Usage
        -:   19:** Alternatively, this file may be used under the terms of the GNU Lesser
        -:   20:** General Public License version 3 as published by the Free Software
        -:   21:** Foundation and appearing in the file LICENSE.LGPL3 included in the
        -:   22:** packaging of this file. Please review the following information to
        -:   23:** ensure the GNU Lesser General Public License version 3 requirements
        -:   24:** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
        -:   25:**
        -:   26:** GNU General Public License Usage
        -:   27:** Alternatively, this file may be used under the terms of the GNU
        -:   28:** General Public License version 2.0 or (at your option) the GNU General
        -:   29:** Public license version 3 or any later version approved by the KDE Free
        -:   30:** Qt Foundation. The licenses are as published by the Free Software
        -:   31:** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
        -:   32:** included in the packaging of this file. Please review the following
        -:   33:** information to ensure the GNU General Public License requirements will
        -:   34:** be met: https://www.gnu.org/licenses/gpl-2.0.html and
        -:   35:** https://www.gnu.org/licenses/gpl-3.0.html.
        -:   36:**
        -:   37:** $QT_END_LICENSE$
        -:   38:**
        -:   39:****************************************************************************/
        -:   40:
        -:   41:#ifndef QBYTEARRAY_H
        -:   42:#define QBYTEARRAY_H
        -:   43:
        -:   44:#include <QtCore/qrefcount.h>
        -:   45:#include <QtCore/qnamespace.h>
        -:   46:#include <QtCore/qarraydata.h>
        -:   47:
        -:   48:#include <stdlib.h>
        -:   49:#include <string.h>
        -:   50:#include <stdarg.h>
        -:   51:
        -:   52:#include <string>
        -:   53:#include <iterator>
        -:   54:
        -:   55:#ifdef truncate
        -:   56:#error qbytearray.h must be included before any header file that defines truncate
        -:   57:#endif
        -:   58:
        -:   59:#if defined(Q_OS_DARWIN) || defined(Q_QDOC)
        -:   60:Q_FORWARD_DECLARE_CF_TYPE(CFData);
        -:   61:Q_FORWARD_DECLARE_OBJC_CLASS(NSData);
        -:   62:#endif
        -:   63:
        -:   64:QT_BEGIN_NAMESPACE
        -:   65:
        -:   66:
        -:   67:/*****************************************************************************
        -:   68:  Safe and portable C string functions; extensions to standard string.h
        -:   69: *****************************************************************************/
        -:   70:
        -:   71:Q_CORE_EXPORT char *qstrdup(const char *);
        -:   72:
        -:   73:inline uint qstrlen(const char *str)
        -:   74:{ return str ? uint(strlen(str)) : 0; }
        -:   75:
        -:   76:inline uint qstrnlen(const char *str, uint maxlen)
        -:   77:{
        -:   78:    uint length = 0;
        -:   79:    if (str) {
        -:   80:        while (length < maxlen && *str++)
        -:   81:            length++;
        -:   82:    }
        -:   83:    return length;
        -:   84:}
        -:   85:
        -:   86:Q_CORE_EXPORT char *qstrcpy(char *dst, const char *src);
        -:   87:Q_CORE_EXPORT char *qstrncpy(char *dst, const char *src, uint len);
        -:   88:
        -:   89:Q_CORE_EXPORT int qstrcmp(const char *str1, const char *str2);
        -:   90:Q_CORE_EXPORT int qstrcmp(const QByteArray &str1, const QByteArray &str2);
        -:   91:Q_CORE_EXPORT int qstrcmp(const QByteArray &str1, const char *str2);
        -:   92:static inline int qstrcmp(const char *str1, const QByteArray &str2)
        -:   93:{ return -qstrcmp(str2, str1); }
        -:   94:
        -:   95:inline int qstrncmp(const char *str1, const char *str2, uint len)
        -:   96:{
        -:   97:    return (str1 && str2) ? strncmp(str1, str2, len)
        -:   98:        : (str1 ? 1 : (str2 ? -1 : 0));
        -:   99:}
        -:  100:Q_CORE_EXPORT int qstricmp(const char *, const char *);
        -:  101:Q_CORE_EXPORT int qstrnicmp(const char *, const char *, uint len);
        -:  102:Q_CORE_EXPORT int qstrnicmp(const char *, qsizetype, const char *, qsizetype = -1);
        -:  103:
        -:  104:// implemented in qvsnprintf.cpp
        -:  105:Q_CORE_EXPORT int qvsnprintf(char *str, size_t n, const char *fmt, va_list ap);
        -:  106:Q_CORE_EXPORT int qsnprintf(char *str, size_t n, const char *fmt, ...);
        -:  107:
        -:  108:// qChecksum: Internet checksum
        -:  109:Q_CORE_EXPORT quint16 qChecksum(const char *s, uint len);                            // ### Qt 6: Remove
        -:  110:Q_CORE_EXPORT quint16 qChecksum(const char *s, uint len, Qt::ChecksumType standard); // ### Qt 6: Use Qt::ChecksumType standard = Qt::ChecksumIso3309
        -:  111:
        -:  112:class QByteRef;
        -:  113:class QString;
        -:  114:class QDataStream;
        -:  115:template <typename T> class QList;
        -:  116:
        -:  117:typedef QArrayData QByteArrayData;
        -:  118:
        -:  119:template<int N> struct QStaticByteArrayData
        -:  120:{
        -:  121:    QByteArrayData ba;
        -:  122:    char data[N + 1];
        -:  123:
        -:  124:    QByteArrayData *data_ptr() const
        -:  125:    {
        -:  126:        Q_ASSERT(ba.ref.isStatic());
        -:  127:        return const_cast<QByteArrayData *>(&ba);
        -:  128:    }
        -:  129:};
        -:  130:
        -:  131:struct QByteArrayDataPtr
        -:  132:{
        -:  133:    QByteArrayData *ptr;
        -:  134:};
        -:  135:
        -:  136:#define Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(size, offset) \
        -:  137:    Q_STATIC_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(size, offset)
        -:  138:    /**/
        -:  139:
        -:  140:#define Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER(size) \
        -:  141:    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(size, sizeof(QByteArrayData)) \
        -:  142:    /**/
        -:  143:
        -:  144:#  define QByteArrayLiteral(str) \
        -:  145:    ([]() -> QByteArray { \
        -:  146:        enum { Size = sizeof(str) - 1 }; \
        -:  147:        static const QStaticByteArrayData<Size> qbytearray_literal = { \
        -:  148:            Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER(Size), \
        -:  149:            str }; \
        -:  150:        QByteArrayDataPtr holder = { qbytearray_literal.data_ptr() }; \
        -:  151:        const QByteArray ba(holder); \
        -:  152:        return ba; \
        -:  153:    }()) \
        -:  154:    /**/
        -:  155:
        -:  156:class Q_CORE_EXPORT QByteArray
        -:  157:{
        -:  158:private:
        -:  159:    typedef QTypedArrayData<char> Data;
        -:  160:
        -:  161:public:
        -:  162:    enum Base64Option {
        -:  163:        Base64Encoding = 0,
        -:  164:        Base64UrlEncoding = 1,
        -:  165:
        -:  166:        KeepTrailingEquals = 0,
        -:  167:        OmitTrailingEquals = 2
        -:  168:    };
        -:  169:    Q_DECLARE_FLAGS(Base64Options, Base64Option)
        -:  170:
        -:  171:    inline QByteArray() noexcept;
        -:  172:    QByteArray(const char *, int size = -1);
        -:  173:    QByteArray(int size, char c);
        -:  174:    QByteArray(int size, Qt::Initialization);
        -:  175:    inline QByteArray(const QByteArray &) noexcept;
        -:  176:    inline ~QByteArray();
        -:  177:
        -:  178:    QByteArray &operator=(const QByteArray &) noexcept;
        -:  179:    QByteArray &operator=(const char *str);
        -:  180:    inline QByteArray(QByteArray && other) noexcept : d(other.d) { other.d = Data::sharedNull(); }
        -:  181:    inline QByteArray &operator=(QByteArray &&other) noexcept
        -:  182:    { qSwap(d, other.d); return *this; }
        -:  183:
        -:  184:    inline void swap(QByteArray &other) noexcept
        -:  185:    { qSwap(d, other.d); }
        -:  186:
        -:  187:    inline int size() const;
        -:  188:    inline bool isEmpty() const;
        -:  189:    void resize(int size);
        -:  190:
        -:  191:    QByteArray &fill(char c, int size = -1);
        -:  192:
        -:  193:    inline int capacity() const;
        -:  194:    inline void reserve(int size);
        -:  195:    inline void squeeze();
        -:  196:
        -:  197:#ifndef QT_NO_CAST_FROM_BYTEARRAY
        -:  198:    inline operator const char *() const;
        -:  199:    inline operator const void *() const;
        -:  200:#endif
        -:  201:    inline char *data();
        -:  202:    inline const char *data() const;
        -:  203:    inline const char *constData() const;
        -:  204:    inline void detach();
        -:  205:    inline bool isDetached() const;
        -:  206:    inline bool isSharedWith(const QByteArray &other) const { return d == other.d; }
        -:  207:    void clear();
        -:  208:
        -:  209:    inline char at(int i) const;
        -:  210:    inline char operator[](int i) const;
        -:  211:    inline char operator[](uint i) const;
        -:  212:    Q_REQUIRED_RESULT inline QByteRef operator[](int i);
        -:  213:    Q_REQUIRED_RESULT inline QByteRef operator[](uint i);
        -:  214:    Q_REQUIRED_RESULT char front() const { return at(0); }
        -:  215:    Q_REQUIRED_RESULT inline QByteRef front();
        -:  216:    Q_REQUIRED_RESULT char back() const { return at(size() - 1); }
        -:  217:    Q_REQUIRED_RESULT inline QByteRef back();
        -:  218:
        -:  219:    int indexOf(char c, int from = 0) const;
        -:  220:    int indexOf(const char *c, int from = 0) const;
        -:  221:    int indexOf(const QByteArray &a, int from = 0) const;
        -:  222:    int lastIndexOf(char c, int from = -1) const;
        -:  223:    int lastIndexOf(const char *c, int from = -1) const;
        -:  224:    int lastIndexOf(const QByteArray &a, int from = -1) const;
        -:  225:
        -:  226:    inline bool contains(char c) const;
        -:  227:    inline bool contains(const char *a) const;
        -:  228:    inline bool contains(const QByteArray &a) const;
        -:  229:    int count(char c) const;
        -:  230:    int count(const char *a) const;
        -:  231:    int count(const QByteArray &a) const;
        -:  232:
        -:  233:    inline int compare(const char *c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
        -:  234:    inline int compare(const QByteArray &a, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
        -:  235:
        -:  236:    Q_REQUIRED_RESULT QByteArray left(int len) const;
        -:  237:    Q_REQUIRED_RESULT QByteArray right(int len) const;
        -:  238:    Q_REQUIRED_RESULT QByteArray mid(int index, int len = -1) const;
        -:  239:    Q_REQUIRED_RESULT QByteArray chopped(int len) const
        -:  240:    { Q_ASSERT(len >= 0); Q_ASSERT(len <= size()); return left(size() - len); }
        -:  241:
        -:  242:    bool startsWith(const QByteArray &a) const;
        -:  243:    bool startsWith(char c) const;
        -:  244:    bool startsWith(const char *c) const;
        -:  245:
        -:  246:    bool endsWith(const QByteArray &a) const;
        -:  247:    bool endsWith(char c) const;
        -:  248:    bool endsWith(const char *c) const;
        -:  249:
        -:  250:    bool isUpper() const;
        -:  251:    bool isLower() const;
        -:  252:
        -:  253:    void truncate(int pos);
        -:  254:    void chop(int n);
        -:  255:
        -:  256:#if defined(Q_COMPILER_REF_QUALIFIERS) && !defined(QT_COMPILING_QSTRING_COMPAT_CPP) && !defined(Q_CLANG_QDOC)
        -:  257:#  if defined(Q_CC_GNU) && !defined(Q_CC_CLANG) && !defined(Q_CC_INTEL) && !__has_cpp_attribute(nodiscard)
        -:  258:    // required due to https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61941
        -:  259:#    pragma push_macro("Q_REQUIRED_RESULT")
        -:  260:#    undef Q_REQUIRED_RESULT
        -:  261:#    define Q_REQUIRED_RESULT
        -:  262:#    define Q_REQUIRED_RESULT_pushed
        -:  263:#  endif
        -:  264:    Q_REQUIRED_RESULT QByteArray toLower() const &
        -:  265:    { return toLower_helper(*this); }
        -:  266:    Q_REQUIRED_RESULT QByteArray toLower() &&
        -:  267:    { return toLower_helper(*this); }
        -:  268:    Q_REQUIRED_RESULT QByteArray toUpper() const &
        -:  269:    { return toUpper_helper(*this); }
        -:  270:    Q_REQUIRED_RESULT QByteArray toUpper() &&
        -:  271:    { return toUpper_helper(*this); }
        -:  272:    Q_REQUIRED_RESULT QByteArray trimmed() const &
        -:  273:    { return trimmed_helper(*this); }
        -:  274:    Q_REQUIRED_RESULT QByteArray trimmed() &&
        -:  275:    { return trimmed_helper(*this); }
        -:  276:    Q_REQUIRED_RESULT QByteArray simplified() const &
        -:  277:    { return simplified_helper(*this); }
        -:  278:    Q_REQUIRED_RESULT QByteArray simplified() &&
        -:  279:    { return simplified_helper(*this); }
        -:  280:#  ifdef Q_REQUIRED_RESULT_pushed
        -:  281:#    pragma pop_macro("Q_REQUIRED_RESULT")
        -:  282:#  endif
        -:  283:#else
        -:  284:    Q_REQUIRED_RESULT QByteArray toLower() const;
        -:  285:    Q_REQUIRED_RESULT QByteArray toUpper() const;
        -:  286:    Q_REQUIRED_RESULT QByteArray trimmed() const;
        -:  287:    Q_REQUIRED_RESULT QByteArray simplified() const;
        -:  288:#endif
        -:  289:
        -:  290:    Q_REQUIRED_RESULT QByteArray leftJustified(int width, char fill = ' ', bool truncate = false) const;
        -:  291:    Q_REQUIRED_RESULT QByteArray rightJustified(int width, char fill = ' ', bool truncate = false) const;
        -:  292:
        -:  293:    QByteArray &prepend(char c);
        -:  294:    inline QByteArray &prepend(int count, char c);
        -:  295:    QByteArray &prepend(const char *s);
        -:  296:    QByteArray &prepend(const char *s, int len);
        -:  297:    QByteArray &prepend(const QByteArray &a);
        -:  298:    QByteArray &append(char c);
        -:  299:    inline QByteArray &append(int count, char c);
        -:  300:    QByteArray &append(const char *s);
        -:  301:    QByteArray &append(const char *s, int len);
        -:  302:    QByteArray &append(const QByteArray &a);
        -:  303:    QByteArray &insert(int i, char c);
        -:  304:    QByteArray &insert(int i, int count, char c);
        -:  305:    QByteArray &insert(int i, const char *s);
        -:  306:    QByteArray &insert(int i, const char *s, int len);
        -:  307:    QByteArray &insert(int i, const QByteArray &a);
        -:  308:    QByteArray &remove(int index, int len);
        -:  309:    QByteArray &replace(int index, int len, const char *s);
        -:  310:    QByteArray &replace(int index, int len, const char *s, int alen);
        -:  311:    QByteArray &replace(int index, int len, const QByteArray &s);
        -:  312:    inline QByteArray &replace(char before, const char *after);
        -:  313:    QByteArray &replace(char before, const QByteArray &after);
        -:  314:    inline QByteArray &replace(const char *before, const char *after);
        -:  315:    QByteArray &replace(const char *before, int bsize, const char *after, int asize);
        -:  316:    QByteArray &replace(const QByteArray &before, const QByteArray &after);
        -:  317:    inline QByteArray &replace(const QByteArray &before, const char *after);
        -:  318:    QByteArray &replace(const char *before, const QByteArray &after);
        -:  319:    QByteArray &replace(char before, char after);
        -:  320:    inline QByteArray &operator+=(char c);
        -:  321:    inline QByteArray &operator+=(const char *s);
        -:  322:    inline QByteArray &operator+=(const QByteArray &a);
        -:  323:
        -:  324:    QList<QByteArray> split(char sep) const;
        -:  325:
        -:  326:    Q_REQUIRED_RESULT QByteArray repeated(int times) const;
        -:  327:
        -:  328:#ifndef QT_NO_CAST_TO_ASCII
        -:  329:    QT_ASCII_CAST_WARN QByteArray &append(const QString &s);
        -:  330:    QT_ASCII_CAST_WARN QByteArray &insert(int i, const QString &s);
        -:  331:    QT_ASCII_CAST_WARN QByteArray &replace(const QString &before, const char *after);
        -:  332:    QT_ASCII_CAST_WARN QByteArray &replace(char c, const QString &after);
        -:  333:    QT_ASCII_CAST_WARN QByteArray &replace(const QString &before, const QByteArray &after);
        -:  334:
        -:  335:    QT_ASCII_CAST_WARN QByteArray &operator+=(const QString &s);
        -:  336:    QT_ASCII_CAST_WARN int indexOf(const QString &s, int from = 0) const;
        -:  337:    QT_ASCII_CAST_WARN int lastIndexOf(const QString &s, int from = -1) const;
        -:  338:#endif
        -:  339:#if !defined(QT_NO_CAST_FROM_ASCII) && !defined(QT_RESTRICTED_CAST_FROM_ASCII)
        -:  340:    inline QT_ASCII_CAST_WARN bool operator==(const QString &s2) const;
        -:  341:    inline QT_ASCII_CAST_WARN bool operator!=(const QString &s2) const;
        -:  342:    inline QT_ASCII_CAST_WARN bool operator<(const QString &s2) const;
        -:  343:    inline QT_ASCII_CAST_WARN bool operator>(const QString &s2) const;
        -:  344:    inline QT_ASCII_CAST_WARN bool operator<=(const QString &s2) const;
        -:  345:    inline QT_ASCII_CAST_WARN bool operator>=(const QString &s2) const;
        -:  346:#endif
        -:  347:
        -:  348:    short toShort(bool *ok = nullptr, int base = 10) const;
        -:  349:    ushort toUShort(bool *ok = nullptr, int base = 10) const;
        -:  350:    int toInt(bool *ok = nullptr, int base = 10) const;
        -:  351:    uint toUInt(bool *ok = nullptr, int base = 10) const;
        -:  352:    long toLong(bool *ok = nullptr, int base = 10) const;
        -:  353:    ulong toULong(bool *ok = nullptr, int base = 10) const;
        -:  354:    qlonglong toLongLong(bool *ok = nullptr, int base = 10) const;
        -:  355:    qulonglong toULongLong(bool *ok = nullptr, int base = 10) const;
        -:  356:    float toFloat(bool *ok = nullptr) const;
        -:  357:    double toDouble(bool *ok = nullptr) const;
        -:  358:    QByteArray toBase64(Base64Options options) const;
        -:  359:    QByteArray toBase64() const; // ### Qt6 merge with previous
        -:  360:    QByteArray toHex() const;
        -:  361:    QByteArray toHex(char separator) const; // ### Qt6 merge with previous
        -:  362:    QByteArray toPercentEncoding(const QByteArray &exclude = QByteArray(),
        -:  363:                                 const QByteArray &include = QByteArray(),
        -:  364:                                 char percent = '%') const;
        -:  365:
        -:  366:    inline QByteArray &setNum(short, int base = 10);
        -:  367:    inline QByteArray &setNum(ushort, int base = 10);
        -:  368:    inline QByteArray &setNum(int, int base = 10);
        -:  369:    inline QByteArray &setNum(uint, int base = 10);
        -:  370:    QByteArray &setNum(qlonglong, int base = 10);
        -:  371:    QByteArray &setNum(qulonglong, int base = 10);
        -:  372:    inline QByteArray &setNum(float, char f = 'g', int prec = 6);
        -:  373:    QByteArray &setNum(double, char f = 'g', int prec = 6);
        -:  374:    QByteArray &setRawData(const char *a, uint n); // ### Qt 6: use an int
        -:  375:
        -:  376:    Q_REQUIRED_RESULT static QByteArray number(int, int base = 10);
        -:  377:    Q_REQUIRED_RESULT static QByteArray number(uint, int base = 10);
        -:  378:    Q_REQUIRED_RESULT static QByteArray number(qlonglong, int base = 10);
        -:  379:    Q_REQUIRED_RESULT static QByteArray number(qulonglong, int base = 10);
        -:  380:    Q_REQUIRED_RESULT static QByteArray number(double, char f = 'g', int prec = 6);
        -:  381:    Q_REQUIRED_RESULT static QByteArray fromRawData(const char *, int size);
        -:  382:    Q_REQUIRED_RESULT static QByteArray fromBase64(const QByteArray &base64, Base64Options options);
        -:  383:    Q_REQUIRED_RESULT static QByteArray fromBase64(const QByteArray &base64); // ### Qt6 merge with previous
        -:  384:    Q_REQUIRED_RESULT static QByteArray fromHex(const QByteArray &hexEncoded);
        -:  385:    Q_REQUIRED_RESULT static QByteArray fromPercentEncoding(const QByteArray &pctEncoded, char percent = '%');
        -:  386:
        -:  387:#if defined(Q_OS_DARWIN) || defined(Q_QDOC)
        -:  388:    static QByteArray fromCFData(CFDataRef data);
        -:  389:    static QByteArray fromRawCFData(CFDataRef data);
        -:  390:    CFDataRef toCFData() const Q_DECL_CF_RETURNS_RETAINED;
        -:  391:    CFDataRef toRawCFData() const Q_DECL_CF_RETURNS_RETAINED;
        -:  392:    static QByteArray fromNSData(const NSData *data);
        -:  393:    static QByteArray fromRawNSData(const NSData *data);
        -:  394:    NSData *toNSData() const Q_DECL_NS_RETURNS_AUTORELEASED;
        -:  395:    NSData *toRawNSData() const Q_DECL_NS_RETURNS_AUTORELEASED;
        -:  396:#endif
        -:  397:
        -:  398:    typedef char *iterator;
        -:  399:    typedef const char *const_iterator;
        -:  400:    typedef iterator Iterator;
        -:  401:    typedef const_iterator ConstIterator;
        -:  402:    typedef std::reverse_iterator<iterator> reverse_iterator;
        -:  403:    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        -:  404:    inline iterator begin();
        -:  405:    inline const_iterator begin() const;
        -:  406:    inline const_iterator cbegin() const;
        -:  407:    inline const_iterator constBegin() const;
        -:  408:    inline iterator end();
        -:  409:    inline const_iterator end() const;
        -:  410:    inline const_iterator cend() const;
        -:  411:    inline const_iterator constEnd() const;
        -:  412:    reverse_iterator rbegin() { return reverse_iterator(end()); }
        -:  413:    reverse_iterator rend() { return reverse_iterator(begin()); }
        -:  414:    const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
        -:  415:    const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
        -:  416:    const_reverse_iterator crbegin() const { return const_reverse_iterator(end()); }
        -:  417:    const_reverse_iterator crend() const { return const_reverse_iterator(begin()); }
        -:  418:
        -:  419:    // stl compatibility
        -:  420:    typedef int size_type;
        -:  421:    typedef qptrdiff difference_type;
        -:  422:    typedef const char & const_reference;
        -:  423:    typedef char & reference;
        -:  424:    typedef char *pointer;
        -:  425:    typedef const char *const_pointer;
        -:  426:    typedef char value_type;
        -:  427:    inline void push_back(char c);
        -:  428:    inline void push_back(const char *c);
        -:  429:    inline void push_back(const QByteArray &a);
        -:  430:    inline void push_front(char c);
        -:  431:    inline void push_front(const char *c);
        -:  432:    inline void push_front(const QByteArray &a);
        -:  433:    void shrink_to_fit() { squeeze(); }
        -:  434:
        -:  435:    static inline QByteArray fromStdString(const std::string &s);
        -:  436:    inline std::string toStdString() const;
        -:  437:
        -:  438:    inline int count() const { return d->size; }
    #####:  439:    int length() const { return d->size; }
    $$$$$:  439-block  0
    $$$$$:  439-block  1
        -:  440:    bool isNull() const;
        -:  441:
        -:  442:    inline QByteArray(QByteArrayDataPtr dd)
        -:  443:        : d(static_cast<Data *>(dd.ptr))
        -:  444:    {
        -:  445:    }
        -:  446:
        -:  447:private:
        -:  448:    operator QNoImplicitBoolCast() const;
        -:  449:    Data *d;
        -:  450:    void reallocData(uint alloc, Data::AllocationOptions options);
        -:  451:    void expand(int i);
        -:  452:    QByteArray nulTerminated() const;
        -:  453:
        -:  454:    static QByteArray toLower_helper(const QByteArray &a);
        -:  455:    static QByteArray toLower_helper(QByteArray &a);
        -:  456:    static QByteArray toUpper_helper(const QByteArray &a);
        -:  457:    static QByteArray toUpper_helper(QByteArray &a);
        -:  458:    static QByteArray trimmed_helper(const QByteArray &a);
        -:  459:    static QByteArray trimmed_helper(QByteArray &a);
        -:  460:    static QByteArray simplified_helper(const QByteArray &a);
        -:  461:    static QByteArray simplified_helper(QByteArray &a);
        -:  462:
        -:  463:    friend class QByteRef;
        -:  464:    friend class QString;
        -:  465:    friend Q_CORE_EXPORT QByteArray qUncompress(const uchar *data, int nbytes);
        -:  466:public:
        -:  467:    typedef Data * DataPtr;
        -:  468:    inline DataPtr &data_ptr() { return d; }
        -:  469:};
        -:  470:
        -:  471:Q_DECLARE_OPERATORS_FOR_FLAGS(QByteArray::Base64Options)
        -:  472:
        -:  473:inline QByteArray::QByteArray() noexcept : d(Data::sharedNull()) { }
    #####:  474:inline QByteArray::~QByteArray() { if (!d->ref.deref()) Data::deallocate(d); }
    $$$$$:  474-block  0
    $$$$$:  474-block  1
    $$$$$:  474-block  2
    $$$$$:  474-block  3
    $$$$$:  474-block  4
    $$$$$:  474-block  5
    $$$$$:  474-block  6
    $$$$$:  474-block  7
        -:  475:inline int QByteArray::size() const
        -:  476:{ return d->size; }
        -:  477:
        -:  478:inline char QByteArray::at(int i) const
        -:  479:{ Q_ASSERT(uint(i) < uint(size())); return d->data()[i]; }
        -:  480:inline char QByteArray::operator[](int i) const
        -:  481:{ Q_ASSERT(uint(i) < uint(size())); return d->data()[i]; }
        -:  482:inline char QByteArray::operator[](uint i) const
        -:  483:{ Q_ASSERT(i < uint(size())); return d->data()[i]; }
        -:  484:
        -:  485:inline bool QByteArray::isEmpty() const
        -:  486:{ return d->size == 0; }
        -:  487:#ifndef QT_NO_CAST_FROM_BYTEARRAY
        -:  488:inline QByteArray::operator const char *() const
        -:  489:{ return d->data(); }
        -:  490:inline QByteArray::operator const void *() const
        -:  491:{ return d->data(); }
        -:  492:#endif
        -:  493:inline char *QByteArray::data()
        -:  494:{ detach(); return d->data(); }
        -:  495:inline const char *QByteArray::data() const
        -:  496:{ return d->data(); }
    #####:  497:inline const char *QByteArray::constData() const
    $$$$$:  497-block  0
    #####:  498:{ return d->data(); }
    $$$$$:  498-block  0
        -:  499:inline void QByteArray::detach()
        -:  500:{ if (d->ref.isShared() || (d->offset != sizeof(QByteArrayData))) reallocData(uint(d->size) + 1u, d->detachFlags()); }
        -:  501:inline bool QByteArray::isDetached() const
        -:  502:{ return !d->ref.isShared(); }
        -:  503:inline QByteArray::QByteArray(const QByteArray &a) noexcept : d(a.d)
        -:  504:{ d->ref.ref(); }
        -:  505:
        -:  506:inline int QByteArray::capacity() const
        -:  507:{ return d->alloc ? d->alloc - 1 : 0; }
        -:  508:
        -:  509:inline void QByteArray::reserve(int asize)
        -:  510:{
        -:  511:    if (d->ref.isShared() || uint(asize) + 1u > d->alloc) {
        -:  512:        reallocData(qMax(uint(size()), uint(asize)) + 1u, d->detachFlags() | Data::CapacityReserved);
        -:  513:    } else {
        -:  514:        // cannot set unconditionally, since d could be the shared_null or
        -:  515:        // otherwise static
        -:  516:        d->capacityReserved = true;
        -:  517:    }
        -:  518:}
        -:  519:
        -:  520:inline void QByteArray::squeeze()
        -:  521:{
        -:  522:    if (d->ref.isShared() || uint(d->size) + 1u < d->alloc) {
        -:  523:        reallocData(uint(d->size) + 1u, d->detachFlags() & ~Data::CapacityReserved);
        -:  524:    } else {
        -:  525:        // cannot set unconditionally, since d could be shared_null or
        -:  526:        // otherwise static.
        -:  527:        d->capacityReserved = false;
        -:  528:    }
        -:  529:}
        -:  530:
        -:  531:namespace QtPrivate {
        -:  532:namespace DeprecatedRefClassBehavior {
        -:  533:    enum class EmittingClass {
        -:  534:        QByteRef,
        -:  535:        QCharRef,
        -:  536:    };
        -:  537:
        -:  538:    enum class WarningType {
        -:  539:        OutOfRange,
        -:  540:        DelayedDetach,
        -:  541:    };
        -:  542:
        -:  543:    Q_CORE_EXPORT Q_DECL_COLD_FUNCTION void warn(WarningType w, EmittingClass c);
        -:  544:} // namespace DeprecatedAssignmentOperatorBehavior
        -:  545:} // namespace QtPrivate
        -:  546:
        -:  547:class
        -:  548:#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
        -:  549:Q_CORE_EXPORT
        -:  550:#endif
        -:  551:QByteRef {  // ### Qt 7: remove
        -:  552:    QByteArray &a;
        -:  553:    int i;
        -:  554:    inline QByteRef(QByteArray &array, int idx)
        -:  555:        : a(array),i(idx) {}
        -:  556:    friend class QByteArray;
        -:  557:public:
        -:  558:    inline operator char() const
        -:  559:    {
        -:  560:        using namespace QtPrivate::DeprecatedRefClassBehavior;
        -:  561:        if (Q_LIKELY(i < a.d->size))
        -:  562:            return a.d->data()[i];
        -:  563:#ifdef QT_DEBUG
        -:  564:        warn(WarningType::OutOfRange, EmittingClass::QByteRef);
        -:  565:#endif
        -:  566:        return char(0);
        -:  567:    }
        -:  568:    inline QByteRef &operator=(char c)
        -:  569:    {
        -:  570:        using namespace QtPrivate::DeprecatedRefClassBehavior;
        -:  571:        if (Q_UNLIKELY(i >= a.d->size)) {
        -:  572:#ifdef QT_DEBUG
        -:  573:            warn(WarningType::OutOfRange, EmittingClass::QByteRef);
        -:  574:#endif
        -:  575:            a.expand(i);
        -:  576:        } else {
        -:  577:#ifdef QT_DEBUG
        -:  578:            if (Q_UNLIKELY(!a.isDetached()))
        -:  579:                warn(WarningType::DelayedDetach, EmittingClass::QByteRef);
        -:  580:#endif
        -:  581:            a.detach();
        -:  582:        }
        -:  583:        a.d->data()[i] = c;
        -:  584:        return *this;
        -:  585:    }
        -:  586:    inline QByteRef &operator=(const QByteRef &c)
        -:  587:    {
        -:  588:        return operator=(char(c));
        -:  589:    }
        -:  590:    inline bool operator==(char c) const
        -:  591:    { return a.d->data()[i] == c; }
        -:  592:    inline bool operator!=(char c) const
        -:  593:    { return a.d->data()[i] != c; }
        -:  594:    inline bool operator>(char c) const
        -:  595:    { return a.d->data()[i] > c; }
        -:  596:    inline bool operator>=(char c) const
        -:  597:    { return a.d->data()[i] >= c; }
        -:  598:    inline bool operator<(char c) const
        -:  599:    { return a.d->data()[i] < c; }
        -:  600:    inline bool operator<=(char c) const
        -:  601:    { return a.d->data()[i] <= c; }
        -:  602:};
        -:  603:
        -:  604:inline QByteRef QByteArray::operator[](int i)
        -:  605:{ Q_ASSERT(i >= 0); detach(); return QByteRef(*this, i); }
        -:  606:inline QByteRef QByteArray::operator[](uint i)
        -:  607:{  detach(); return QByteRef(*this, i); }
        -:  608:inline QByteRef QByteArray::front() { return operator[](0); }
        -:  609:inline QByteRef QByteArray::back() { return operator[](size() - 1); }
        -:  610:inline QByteArray::iterator QByteArray::begin()
        -:  611:{ detach(); return d->data(); }
        -:  612:inline QByteArray::const_iterator QByteArray::begin() const
        -:  613:{ return d->data(); }
        -:  614:inline QByteArray::const_iterator QByteArray::cbegin() const
        -:  615:{ return d->data(); }
        -:  616:inline QByteArray::const_iterator QByteArray::constBegin() const
        -:  617:{ return d->data(); }
        -:  618:inline QByteArray::iterator QByteArray::end()
        -:  619:{ detach(); return d->data() + d->size; }
        -:  620:inline QByteArray::const_iterator QByteArray::end() const
        -:  621:{ return d->data() + d->size; }
        -:  622:inline QByteArray::const_iterator QByteArray::cend() const
        -:  623:{ return d->data() + d->size; }
        -:  624:inline QByteArray::const_iterator QByteArray::constEnd() const
        -:  625:{ return d->data() + d->size; }
        -:  626:inline QByteArray &QByteArray::append(int n, char ch)
        -:  627:{ return insert(d->size, n, ch); }
        -:  628:inline QByteArray &QByteArray::prepend(int n, char ch)
        -:  629:{ return insert(0, n, ch); }
        -:  630:inline QByteArray &QByteArray::operator+=(char c)
        -:  631:{ return append(c); }
        -:  632:inline QByteArray &QByteArray::operator+=(const char *s)
        -:  633:{ return append(s); }
        -:  634:inline QByteArray &QByteArray::operator+=(const QByteArray &a)
        -:  635:{ return append(a); }
        -:  636:inline void QByteArray::push_back(char c)
        -:  637:{ append(c); }
        -:  638:inline void QByteArray::push_back(const char *c)
        -:  639:{ append(c); }
        -:  640:inline void QByteArray::push_back(const QByteArray &a)
        -:  641:{ append(a); }
        -:  642:inline void QByteArray::push_front(char c)
        -:  643:{ prepend(c); }
        -:  644:inline void QByteArray::push_front(const char *c)
        -:  645:{ prepend(c); }
        -:  646:inline void QByteArray::push_front(const QByteArray &a)
        -:  647:{ prepend(a); }
        -:  648:inline bool QByteArray::contains(const QByteArray &a) const
        -:  649:{ return indexOf(a) != -1; }
        -:  650:inline bool QByteArray::contains(char c) const
        -:  651:{ return indexOf(c) != -1; }
        -:  652:inline int QByteArray::compare(const char *c, Qt::CaseSensitivity cs) const
        -:  653:{
        -:  654:    return cs == Qt::CaseSensitive ? qstrcmp(*this, c) :
        -:  655:                                     qstrnicmp(data(), size(), c, -1);
        -:  656:}
        -:  657:inline int QByteArray::compare(const QByteArray &a, Qt::CaseSensitivity cs) const
        -:  658:{
        -:  659:    return cs == Qt::CaseSensitive ? qstrcmp(*this, a) :
        -:  660:                                     qstrnicmp(data(), size(), a.data(), a.size());
        -:  661:}
        -:  662:inline bool operator==(const QByteArray &a1, const QByteArray &a2) noexcept
        -:  663:{ return (a1.size() == a2.size()) && (memcmp(a1.constData(), a2.constData(), a1.size())==0); }
        -:  664:inline bool operator==(const QByteArray &a1, const char *a2) noexcept
        -:  665:{ return a2 ? qstrcmp(a1,a2) == 0 : a1.isEmpty(); }
        -:  666:inline bool operator==(const char *a1, const QByteArray &a2) noexcept
        -:  667:{ return a1 ? qstrcmp(a1,a2) == 0 : a2.isEmpty(); }
        -:  668:inline bool operator!=(const QByteArray &a1, const QByteArray &a2) noexcept
        -:  669:{ return !(a1==a2); }
        -:  670:inline bool operator!=(const QByteArray &a1, const char *a2) noexcept
        -:  671:{ return a2 ? qstrcmp(a1,a2) != 0 : !a1.isEmpty(); }
        -:  672:inline bool operator!=(const char *a1, const QByteArray &a2) noexcept
        -:  673:{ return a1 ? qstrcmp(a1,a2) != 0 : !a2.isEmpty(); }
        -:  674:inline bool operator<(const QByteArray &a1, const QByteArray &a2) noexcept
        -:  675:{ return qstrcmp(a1, a2) < 0; }
        -:  676: inline bool operator<(const QByteArray &a1, const char *a2) noexcept
        -:  677:{ return qstrcmp(a1, a2) < 0; }
        -:  678:inline bool operator<(const char *a1, const QByteArray &a2) noexcept
        -:  679:{ return qstrcmp(a1, a2) < 0; }
        -:  680:inline bool operator<=(const QByteArray &a1, const QByteArray &a2) noexcept
        -:  681:{ return qstrcmp(a1, a2) <= 0; }
        -:  682:inline bool operator<=(const QByteArray &a1, const char *a2) noexcept
        -:  683:{ return qstrcmp(a1, a2) <= 0; }
        -:  684:inline bool operator<=(const char *a1, const QByteArray &a2) noexcept
        -:  685:{ return qstrcmp(a1, a2) <= 0; }
        -:  686:inline bool operator>(const QByteArray &a1, const QByteArray &a2) noexcept
        -:  687:{ return qstrcmp(a1, a2) > 0; }
        -:  688:inline bool operator>(const QByteArray &a1, const char *a2) noexcept
        -:  689:{ return qstrcmp(a1, a2) > 0; }
        -:  690:inline bool operator>(const char *a1, const QByteArray &a2) noexcept
        -:  691:{ return qstrcmp(a1, a2) > 0; }
        -:  692:inline bool operator>=(const QByteArray &a1, const QByteArray &a2) noexcept
        -:  693:{ return qstrcmp(a1, a2) >= 0; }
        -:  694:inline bool operator>=(const QByteArray &a1, const char *a2) noexcept
        -:  695:{ return qstrcmp(a1, a2) >= 0; }
        -:  696:inline bool operator>=(const char *a1, const QByteArray &a2) noexcept
        -:  697:{ return qstrcmp(a1, a2) >= 0; }
        -:  698:#if !defined(QT_USE_QSTRINGBUILDER)
        -:  699:inline const QByteArray operator+(const QByteArray &a1, const QByteArray &a2)
        -:  700:{ return QByteArray(a1) += a2; }
        -:  701:inline const QByteArray operator+(const QByteArray &a1, const char *a2)
        -:  702:{ return QByteArray(a1) += a2; }
        -:  703:inline const QByteArray operator+(const QByteArray &a1, char a2)
        -:  704:{ return QByteArray(a1) += a2; }
        -:  705:inline const QByteArray operator+(const char *a1, const QByteArray &a2)
        -:  706:{ return QByteArray(a1) += a2; }
        -:  707:inline const QByteArray operator+(char a1, const QByteArray &a2)
        -:  708:{ return QByteArray(&a1, 1) += a2; }
        -:  709:#endif // QT_USE_QSTRINGBUILDER
        -:  710:inline bool QByteArray::contains(const char *c) const
        -:  711:{ return indexOf(c) != -1; }
        -:  712:inline QByteArray &QByteArray::replace(char before, const char *c)
        -:  713:{ return replace(&before, 1, c, qstrlen(c)); }
        -:  714:inline QByteArray &QByteArray::replace(const QByteArray &before, const char *c)
        -:  715:{ return replace(before.constData(), before.size(), c, qstrlen(c)); }
        -:  716:inline QByteArray &QByteArray::replace(const char *before, const char *after)
        -:  717:{ return replace(before, qstrlen(before), after, qstrlen(after)); }
        -:  718:
        -:  719:inline QByteArray &QByteArray::setNum(short n, int base)
        -:  720:{ return base == 10 ? setNum(qlonglong(n), base) : setNum(qulonglong(ushort(n)), base); }
        -:  721:inline QByteArray &QByteArray::setNum(ushort n, int base)
        -:  722:{ return setNum(qulonglong(n), base); }
        -:  723:inline QByteArray &QByteArray::setNum(int n, int base)
        -:  724:{ return base == 10 ? setNum(qlonglong(n), base) : setNum(qulonglong(uint(n)), base); }
        -:  725:inline QByteArray &QByteArray::setNum(uint n, int base)
        -:  726:{ return setNum(qulonglong(n), base); }
        -:  727:inline QByteArray &QByteArray::setNum(float n, char f, int prec)
        -:  728:{ return setNum(double(n),f,prec); }
        -:  729:
    #####:  730:inline std::string QByteArray::toStdString() const
    $$$$$:  730-block  0
    #####:  731:{ return std::string(constData(), length()); }
    $$$$$:  731-block  0
        -:  732:
        -:  733:inline QByteArray QByteArray::fromStdString(const std::string &s)
        -:  734:{ return QByteArray(s.data(), int(s.size())); }
        -:  735:
        -:  736:#if !defined(QT_NO_DATASTREAM) || (defined(QT_BOOTSTRAPPED) && !defined(QT_BUILD_QMAKE))
        -:  737:Q_CORE_EXPORT QDataStream &operator<<(QDataStream &, const QByteArray &);
        -:  738:Q_CORE_EXPORT QDataStream &operator>>(QDataStream &, QByteArray &);
        -:  739:#endif
        -:  740:
        -:  741:#ifndef QT_NO_COMPRESS
        -:  742:Q_CORE_EXPORT QByteArray qCompress(const uchar* data, int nbytes, int compressionLevel = -1);
        -:  743:Q_CORE_EXPORT QByteArray qUncompress(const uchar* data, int nbytes);
        -:  744:inline QByteArray qCompress(const QByteArray& data, int compressionLevel = -1)
        -:  745:{ return qCompress(reinterpret_cast<const uchar *>(data.constData()), data.size(), compressionLevel); }
        -:  746:inline QByteArray qUncompress(const QByteArray& data)
        -:  747:{ return qUncompress(reinterpret_cast<const uchar*>(data.constData()), data.size()); }
        -:  748:#endif
        -:  749:
        -:  750:Q_DECLARE_SHARED(QByteArray)
        -:  751:
        -:  752:QT_END_NAMESPACE
        -:  753:
        -:  754:#endif // QBYTEARRAY_H
